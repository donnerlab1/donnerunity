// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto
#pragma warning disable 1591
#region Designer generated code

using System;
using System.Threading;
using System.Threading.Tasks;
using grpc = global::Grpc.Core;

namespace Lnrpc {
  /// <summary>
  /// The WalletUnlocker service is used to set up a wallet password for
  /// lnd at first startup, and unlock a previously set up wallet.
  /// </summary>
  public static partial class WalletUnlocker
  {
    static readonly string __ServiceName = "lnrpc.WalletUnlocker";

    static readonly grpc::Marshaller<global::Lnrpc.GenSeedRequest> __Marshaller_GenSeedRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.GenSeedRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.GenSeedResponse> __Marshaller_GenSeedResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.GenSeedResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.InitWalletRequest> __Marshaller_InitWalletRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.InitWalletRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.InitWalletResponse> __Marshaller_InitWalletResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.InitWalletResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.UnlockWalletRequest> __Marshaller_UnlockWalletRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.UnlockWalletRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.UnlockWalletResponse> __Marshaller_UnlockWalletResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.UnlockWalletResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ChangePasswordRequest> __Marshaller_ChangePasswordRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ChangePasswordRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ChangePasswordResponse> __Marshaller_ChangePasswordResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ChangePasswordResponse.Parser.ParseFrom);

    static readonly grpc::Method<global::Lnrpc.GenSeedRequest, global::Lnrpc.GenSeedResponse> __Method_GenSeed = new grpc::Method<global::Lnrpc.GenSeedRequest, global::Lnrpc.GenSeedResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GenSeed",
        __Marshaller_GenSeedRequest,
        __Marshaller_GenSeedResponse);

    static readonly grpc::Method<global::Lnrpc.InitWalletRequest, global::Lnrpc.InitWalletResponse> __Method_InitWallet = new grpc::Method<global::Lnrpc.InitWalletRequest, global::Lnrpc.InitWalletResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "InitWallet",
        __Marshaller_InitWalletRequest,
        __Marshaller_InitWalletResponse);

    static readonly grpc::Method<global::Lnrpc.UnlockWalletRequest, global::Lnrpc.UnlockWalletResponse> __Method_UnlockWallet = new grpc::Method<global::Lnrpc.UnlockWalletRequest, global::Lnrpc.UnlockWalletResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "UnlockWallet",
        __Marshaller_UnlockWalletRequest,
        __Marshaller_UnlockWalletResponse);

    static readonly grpc::Method<global::Lnrpc.ChangePasswordRequest, global::Lnrpc.ChangePasswordResponse> __Method_ChangePassword = new grpc::Method<global::Lnrpc.ChangePasswordRequest, global::Lnrpc.ChangePasswordResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ChangePassword",
        __Marshaller_ChangePasswordRequest,
        __Marshaller_ChangePasswordResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Lnrpc.RpcReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of WalletUnlocker</summary>
    public abstract partial class WalletUnlockerBase
    {
      /// <summary>
      ///*
      ///GenSeed is the first method that should be used to instantiate a new lnd
      ///instance. This method allows a caller to generate a new aezeed cipher seed
      ///given an optional passphrase. If provided, the passphrase will be necessary
      ///to decrypt the cipherseed to expose the internal wallet seed.
      ///
      ///Once the cipherseed is obtained and verified by the user, the InitWallet
      ///method should be used to commit the newly generated seed, and create the
      ///wallet.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.GenSeedResponse> GenSeed(global::Lnrpc.GenSeedRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* 
      ///InitWallet is used when lnd is starting up for the first time to fully
      ///initialize the daemon and its internal wallet. At the very least a wallet
      ///password must be provided. This will be used to encrypt sensitive material
      ///on disk.
      ///
      ///In the case of a recovery scenario, the user can also specify their aezeed
      ///mnemonic and passphrase. If set, then the daemon will use this prior state
      ///to initialize its internal wallet.
      ///
      ///Alternatively, this can be used along with the GenSeed RPC to obtain a
      ///seed, then present it to the user. Once it has been verified by the user,
      ///the seed can be fed into this RPC in order to commit the new wallet.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.InitWalletResponse> InitWallet(global::Lnrpc.InitWalletRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `unlock`
      ///UnlockWallet is used at startup of lnd to provide a password to unlock
      ///the wallet database.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.UnlockWalletResponse> UnlockWallet(global::Lnrpc.UnlockWalletRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `changepassword`
      ///ChangePassword changes the password of the encrypted wallet. This will
      ///automatically unlock the wallet database if successful.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.ChangePasswordResponse> ChangePassword(global::Lnrpc.ChangePasswordRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for WalletUnlocker</summary>
    public partial class WalletUnlockerClient : grpc::ClientBase<WalletUnlockerClient>
    {
      /// <summary>Creates a new client for WalletUnlocker</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public WalletUnlockerClient(grpc::Channel channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for WalletUnlocker that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public WalletUnlockerClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected WalletUnlockerClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected WalletUnlockerClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      ///*
      ///GenSeed is the first method that should be used to instantiate a new lnd
      ///instance. This method allows a caller to generate a new aezeed cipher seed
      ///given an optional passphrase. If provided, the passphrase will be necessary
      ///to decrypt the cipherseed to expose the internal wallet seed.
      ///
      ///Once the cipherseed is obtained and verified by the user, the InitWallet
      ///method should be used to commit the newly generated seed, and create the
      ///wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.GenSeedResponse GenSeed(global::Lnrpc.GenSeedRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GenSeed(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///GenSeed is the first method that should be used to instantiate a new lnd
      ///instance. This method allows a caller to generate a new aezeed cipher seed
      ///given an optional passphrase. If provided, the passphrase will be necessary
      ///to decrypt the cipherseed to expose the internal wallet seed.
      ///
      ///Once the cipherseed is obtained and verified by the user, the InitWallet
      ///method should be used to commit the newly generated seed, and create the
      ///wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.GenSeedResponse GenSeed(global::Lnrpc.GenSeedRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GenSeed, null, options, request);
      }
      /// <summary>
      ///*
      ///GenSeed is the first method that should be used to instantiate a new lnd
      ///instance. This method allows a caller to generate a new aezeed cipher seed
      ///given an optional passphrase. If provided, the passphrase will be necessary
      ///to decrypt the cipherseed to expose the internal wallet seed.
      ///
      ///Once the cipherseed is obtained and verified by the user, the InitWallet
      ///method should be used to commit the newly generated seed, and create the
      ///wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.GenSeedResponse> GenSeedAsync(global::Lnrpc.GenSeedRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GenSeedAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///GenSeed is the first method that should be used to instantiate a new lnd
      ///instance. This method allows a caller to generate a new aezeed cipher seed
      ///given an optional passphrase. If provided, the passphrase will be necessary
      ///to decrypt the cipherseed to expose the internal wallet seed.
      ///
      ///Once the cipherseed is obtained and verified by the user, the InitWallet
      ///method should be used to commit the newly generated seed, and create the
      ///wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.GenSeedResponse> GenSeedAsync(global::Lnrpc.GenSeedRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GenSeed, null, options, request);
      }
      /// <summary>
      ///* 
      ///InitWallet is used when lnd is starting up for the first time to fully
      ///initialize the daemon and its internal wallet. At the very least a wallet
      ///password must be provided. This will be used to encrypt sensitive material
      ///on disk.
      ///
      ///In the case of a recovery scenario, the user can also specify their aezeed
      ///mnemonic and passphrase. If set, then the daemon will use this prior state
      ///to initialize its internal wallet.
      ///
      ///Alternatively, this can be used along with the GenSeed RPC to obtain a
      ///seed, then present it to the user. Once it has been verified by the user,
      ///the seed can be fed into this RPC in order to commit the new wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.InitWalletResponse InitWallet(global::Lnrpc.InitWalletRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return InitWallet(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* 
      ///InitWallet is used when lnd is starting up for the first time to fully
      ///initialize the daemon and its internal wallet. At the very least a wallet
      ///password must be provided. This will be used to encrypt sensitive material
      ///on disk.
      ///
      ///In the case of a recovery scenario, the user can also specify their aezeed
      ///mnemonic and passphrase. If set, then the daemon will use this prior state
      ///to initialize its internal wallet.
      ///
      ///Alternatively, this can be used along with the GenSeed RPC to obtain a
      ///seed, then present it to the user. Once it has been verified by the user,
      ///the seed can be fed into this RPC in order to commit the new wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.InitWalletResponse InitWallet(global::Lnrpc.InitWalletRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_InitWallet, null, options, request);
      }
      /// <summary>
      ///* 
      ///InitWallet is used when lnd is starting up for the first time to fully
      ///initialize the daemon and its internal wallet. At the very least a wallet
      ///password must be provided. This will be used to encrypt sensitive material
      ///on disk.
      ///
      ///In the case of a recovery scenario, the user can also specify their aezeed
      ///mnemonic and passphrase. If set, then the daemon will use this prior state
      ///to initialize its internal wallet.
      ///
      ///Alternatively, this can be used along with the GenSeed RPC to obtain a
      ///seed, then present it to the user. Once it has been verified by the user,
      ///the seed can be fed into this RPC in order to commit the new wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.InitWalletResponse> InitWalletAsync(global::Lnrpc.InitWalletRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return InitWalletAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* 
      ///InitWallet is used when lnd is starting up for the first time to fully
      ///initialize the daemon and its internal wallet. At the very least a wallet
      ///password must be provided. This will be used to encrypt sensitive material
      ///on disk.
      ///
      ///In the case of a recovery scenario, the user can also specify their aezeed
      ///mnemonic and passphrase. If set, then the daemon will use this prior state
      ///to initialize its internal wallet.
      ///
      ///Alternatively, this can be used along with the GenSeed RPC to obtain a
      ///seed, then present it to the user. Once it has been verified by the user,
      ///the seed can be fed into this RPC in order to commit the new wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.InitWalletResponse> InitWalletAsync(global::Lnrpc.InitWalletRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_InitWallet, null, options, request);
      }
      /// <summary>
      ///* lncli: `unlock`
      ///UnlockWallet is used at startup of lnd to provide a password to unlock
      ///the wallet database.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.UnlockWalletResponse UnlockWallet(global::Lnrpc.UnlockWalletRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return UnlockWallet(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `unlock`
      ///UnlockWallet is used at startup of lnd to provide a password to unlock
      ///the wallet database.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.UnlockWalletResponse UnlockWallet(global::Lnrpc.UnlockWalletRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_UnlockWallet, null, options, request);
      }
      /// <summary>
      ///* lncli: `unlock`
      ///UnlockWallet is used at startup of lnd to provide a password to unlock
      ///the wallet database.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.UnlockWalletResponse> UnlockWalletAsync(global::Lnrpc.UnlockWalletRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return UnlockWalletAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `unlock`
      ///UnlockWallet is used at startup of lnd to provide a password to unlock
      ///the wallet database.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.UnlockWalletResponse> UnlockWalletAsync(global::Lnrpc.UnlockWalletRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_UnlockWallet, null, options, request);
      }
      /// <summary>
      ///* lncli: `changepassword`
      ///ChangePassword changes the password of the encrypted wallet. This will
      ///automatically unlock the wallet database if successful.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChangePasswordResponse ChangePassword(global::Lnrpc.ChangePasswordRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ChangePassword(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `changepassword`
      ///ChangePassword changes the password of the encrypted wallet. This will
      ///automatically unlock the wallet database if successful.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChangePasswordResponse ChangePassword(global::Lnrpc.ChangePasswordRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ChangePassword, null, options, request);
      }
      /// <summary>
      ///* lncli: `changepassword`
      ///ChangePassword changes the password of the encrypted wallet. This will
      ///automatically unlock the wallet database if successful.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChangePasswordResponse> ChangePasswordAsync(global::Lnrpc.ChangePasswordRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ChangePasswordAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `changepassword`
      ///ChangePassword changes the password of the encrypted wallet. This will
      ///automatically unlock the wallet database if successful.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChangePasswordResponse> ChangePasswordAsync(global::Lnrpc.ChangePasswordRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ChangePassword, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override WalletUnlockerClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new WalletUnlockerClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static grpc::ServerServiceDefinition BindService(WalletUnlockerBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_GenSeed, serviceImpl.GenSeed)
          .AddMethod(__Method_InitWallet, serviceImpl.InitWallet)
          .AddMethod(__Method_UnlockWallet, serviceImpl.UnlockWallet)
          .AddMethod(__Method_ChangePassword, serviceImpl.ChangePassword).Build();
    }

  }
  public static partial class Lightning
  {
    static readonly string __ServiceName = "lnrpc.Lightning";

    static readonly grpc::Marshaller<global::Lnrpc.WalletBalanceRequest> __Marshaller_WalletBalanceRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.WalletBalanceRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.WalletBalanceResponse> __Marshaller_WalletBalanceResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.WalletBalanceResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ChannelBalanceRequest> __Marshaller_ChannelBalanceRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ChannelBalanceRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ChannelBalanceResponse> __Marshaller_ChannelBalanceResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ChannelBalanceResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.GetTransactionsRequest> __Marshaller_GetTransactionsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.GetTransactionsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.TransactionDetails> __Marshaller_TransactionDetails = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.TransactionDetails.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.SendCoinsRequest> __Marshaller_SendCoinsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.SendCoinsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.SendCoinsResponse> __Marshaller_SendCoinsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.SendCoinsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.Transaction> __Marshaller_Transaction = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.Transaction.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.SendManyRequest> __Marshaller_SendManyRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.SendManyRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.SendManyResponse> __Marshaller_SendManyResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.SendManyResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.NewAddressRequest> __Marshaller_NewAddressRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.NewAddressRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.NewAddressResponse> __Marshaller_NewAddressResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.NewAddressResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.NewWitnessAddressRequest> __Marshaller_NewWitnessAddressRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.NewWitnessAddressRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.SignMessageRequest> __Marshaller_SignMessageRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.SignMessageRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.SignMessageResponse> __Marshaller_SignMessageResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.SignMessageResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.VerifyMessageRequest> __Marshaller_VerifyMessageRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.VerifyMessageRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.VerifyMessageResponse> __Marshaller_VerifyMessageResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.VerifyMessageResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ConnectPeerRequest> __Marshaller_ConnectPeerRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ConnectPeerRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ConnectPeerResponse> __Marshaller_ConnectPeerResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ConnectPeerResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.DisconnectPeerRequest> __Marshaller_DisconnectPeerRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.DisconnectPeerRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.DisconnectPeerResponse> __Marshaller_DisconnectPeerResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.DisconnectPeerResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ListPeersRequest> __Marshaller_ListPeersRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ListPeersRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ListPeersResponse> __Marshaller_ListPeersResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ListPeersResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.GetInfoRequest> __Marshaller_GetInfoRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.GetInfoRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.GetInfoResponse> __Marshaller_GetInfoResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.GetInfoResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.PendingChannelsRequest> __Marshaller_PendingChannelsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.PendingChannelsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.PendingChannelsResponse> __Marshaller_PendingChannelsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.PendingChannelsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ListChannelsRequest> __Marshaller_ListChannelsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ListChannelsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ListChannelsResponse> __Marshaller_ListChannelsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ListChannelsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ClosedChannelsRequest> __Marshaller_ClosedChannelsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ClosedChannelsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ClosedChannelsResponse> __Marshaller_ClosedChannelsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ClosedChannelsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.OpenChannelRequest> __Marshaller_OpenChannelRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.OpenChannelRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ChannelPoint> __Marshaller_ChannelPoint = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ChannelPoint.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.OpenStatusUpdate> __Marshaller_OpenStatusUpdate = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.OpenStatusUpdate.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.CloseChannelRequest> __Marshaller_CloseChannelRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.CloseChannelRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.CloseStatusUpdate> __Marshaller_CloseStatusUpdate = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.CloseStatusUpdate.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.SendRequest> __Marshaller_SendRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.SendRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.SendResponse> __Marshaller_SendResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.SendResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.SendToRouteRequest> __Marshaller_SendToRouteRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.SendToRouteRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.Invoice> __Marshaller_Invoice = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.Invoice.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.AddInvoiceResponse> __Marshaller_AddInvoiceResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.AddInvoiceResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ListInvoiceRequest> __Marshaller_ListInvoiceRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ListInvoiceRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ListInvoiceResponse> __Marshaller_ListInvoiceResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ListInvoiceResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.PaymentHash> __Marshaller_PaymentHash = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.PaymentHash.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.InvoiceSubscription> __Marshaller_InvoiceSubscription = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.InvoiceSubscription.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.PayReqString> __Marshaller_PayReqString = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.PayReqString.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.PayReq> __Marshaller_PayReq = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.PayReq.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ListPaymentsRequest> __Marshaller_ListPaymentsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ListPaymentsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ListPaymentsResponse> __Marshaller_ListPaymentsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ListPaymentsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.DeleteAllPaymentsRequest> __Marshaller_DeleteAllPaymentsRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.DeleteAllPaymentsRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.DeleteAllPaymentsResponse> __Marshaller_DeleteAllPaymentsResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.DeleteAllPaymentsResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ChannelGraphRequest> __Marshaller_ChannelGraphRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ChannelGraphRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ChannelGraph> __Marshaller_ChannelGraph = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ChannelGraph.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ChanInfoRequest> __Marshaller_ChanInfoRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ChanInfoRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ChannelEdge> __Marshaller_ChannelEdge = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ChannelEdge.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.NodeInfoRequest> __Marshaller_NodeInfoRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.NodeInfoRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.NodeInfo> __Marshaller_NodeInfo = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.NodeInfo.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.QueryRoutesRequest> __Marshaller_QueryRoutesRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.QueryRoutesRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.QueryRoutesResponse> __Marshaller_QueryRoutesResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.QueryRoutesResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.NetworkInfoRequest> __Marshaller_NetworkInfoRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.NetworkInfoRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.NetworkInfo> __Marshaller_NetworkInfo = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.NetworkInfo.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.StopRequest> __Marshaller_StopRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.StopRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.StopResponse> __Marshaller_StopResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.StopResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.GraphTopologySubscription> __Marshaller_GraphTopologySubscription = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.GraphTopologySubscription.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.GraphTopologyUpdate> __Marshaller_GraphTopologyUpdate = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.GraphTopologyUpdate.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.DebugLevelRequest> __Marshaller_DebugLevelRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.DebugLevelRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.DebugLevelResponse> __Marshaller_DebugLevelResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.DebugLevelResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.FeeReportRequest> __Marshaller_FeeReportRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.FeeReportRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.FeeReportResponse> __Marshaller_FeeReportResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.FeeReportResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.PolicyUpdateRequest> __Marshaller_PolicyUpdateRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.PolicyUpdateRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.PolicyUpdateResponse> __Marshaller_PolicyUpdateResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.PolicyUpdateResponse.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ForwardingHistoryRequest> __Marshaller_ForwardingHistoryRequest = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ForwardingHistoryRequest.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::Lnrpc.ForwardingHistoryResponse> __Marshaller_ForwardingHistoryResponse = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::Lnrpc.ForwardingHistoryResponse.Parser.ParseFrom);

    static readonly grpc::Method<global::Lnrpc.WalletBalanceRequest, global::Lnrpc.WalletBalanceResponse> __Method_WalletBalance = new grpc::Method<global::Lnrpc.WalletBalanceRequest, global::Lnrpc.WalletBalanceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "WalletBalance",
        __Marshaller_WalletBalanceRequest,
        __Marshaller_WalletBalanceResponse);

    static readonly grpc::Method<global::Lnrpc.ChannelBalanceRequest, global::Lnrpc.ChannelBalanceResponse> __Method_ChannelBalance = new grpc::Method<global::Lnrpc.ChannelBalanceRequest, global::Lnrpc.ChannelBalanceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ChannelBalance",
        __Marshaller_ChannelBalanceRequest,
        __Marshaller_ChannelBalanceResponse);

    static readonly grpc::Method<global::Lnrpc.GetTransactionsRequest, global::Lnrpc.TransactionDetails> __Method_GetTransactions = new grpc::Method<global::Lnrpc.GetTransactionsRequest, global::Lnrpc.TransactionDetails>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetTransactions",
        __Marshaller_GetTransactionsRequest,
        __Marshaller_TransactionDetails);

    static readonly grpc::Method<global::Lnrpc.SendCoinsRequest, global::Lnrpc.SendCoinsResponse> __Method_SendCoins = new grpc::Method<global::Lnrpc.SendCoinsRequest, global::Lnrpc.SendCoinsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SendCoins",
        __Marshaller_SendCoinsRequest,
        __Marshaller_SendCoinsResponse);

    static readonly grpc::Method<global::Lnrpc.GetTransactionsRequest, global::Lnrpc.Transaction> __Method_SubscribeTransactions = new grpc::Method<global::Lnrpc.GetTransactionsRequest, global::Lnrpc.Transaction>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "SubscribeTransactions",
        __Marshaller_GetTransactionsRequest,
        __Marshaller_Transaction);

    static readonly grpc::Method<global::Lnrpc.SendManyRequest, global::Lnrpc.SendManyResponse> __Method_SendMany = new grpc::Method<global::Lnrpc.SendManyRequest, global::Lnrpc.SendManyResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SendMany",
        __Marshaller_SendManyRequest,
        __Marshaller_SendManyResponse);

    static readonly grpc::Method<global::Lnrpc.NewAddressRequest, global::Lnrpc.NewAddressResponse> __Method_NewAddress = new grpc::Method<global::Lnrpc.NewAddressRequest, global::Lnrpc.NewAddressResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "NewAddress",
        __Marshaller_NewAddressRequest,
        __Marshaller_NewAddressResponse);

    static readonly grpc::Method<global::Lnrpc.NewWitnessAddressRequest, global::Lnrpc.NewAddressResponse> __Method_NewWitnessAddress = new grpc::Method<global::Lnrpc.NewWitnessAddressRequest, global::Lnrpc.NewAddressResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "NewWitnessAddress",
        __Marshaller_NewWitnessAddressRequest,
        __Marshaller_NewAddressResponse);

    static readonly grpc::Method<global::Lnrpc.SignMessageRequest, global::Lnrpc.SignMessageResponse> __Method_SignMessage = new grpc::Method<global::Lnrpc.SignMessageRequest, global::Lnrpc.SignMessageResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SignMessage",
        __Marshaller_SignMessageRequest,
        __Marshaller_SignMessageResponse);

    static readonly grpc::Method<global::Lnrpc.VerifyMessageRequest, global::Lnrpc.VerifyMessageResponse> __Method_VerifyMessage = new grpc::Method<global::Lnrpc.VerifyMessageRequest, global::Lnrpc.VerifyMessageResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "VerifyMessage",
        __Marshaller_VerifyMessageRequest,
        __Marshaller_VerifyMessageResponse);

    static readonly grpc::Method<global::Lnrpc.ConnectPeerRequest, global::Lnrpc.ConnectPeerResponse> __Method_ConnectPeer = new grpc::Method<global::Lnrpc.ConnectPeerRequest, global::Lnrpc.ConnectPeerResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ConnectPeer",
        __Marshaller_ConnectPeerRequest,
        __Marshaller_ConnectPeerResponse);

    static readonly grpc::Method<global::Lnrpc.DisconnectPeerRequest, global::Lnrpc.DisconnectPeerResponse> __Method_DisconnectPeer = new grpc::Method<global::Lnrpc.DisconnectPeerRequest, global::Lnrpc.DisconnectPeerResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DisconnectPeer",
        __Marshaller_DisconnectPeerRequest,
        __Marshaller_DisconnectPeerResponse);

    static readonly grpc::Method<global::Lnrpc.ListPeersRequest, global::Lnrpc.ListPeersResponse> __Method_ListPeers = new grpc::Method<global::Lnrpc.ListPeersRequest, global::Lnrpc.ListPeersResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListPeers",
        __Marshaller_ListPeersRequest,
        __Marshaller_ListPeersResponse);

    static readonly grpc::Method<global::Lnrpc.GetInfoRequest, global::Lnrpc.GetInfoResponse> __Method_GetInfo = new grpc::Method<global::Lnrpc.GetInfoRequest, global::Lnrpc.GetInfoResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetInfo",
        __Marshaller_GetInfoRequest,
        __Marshaller_GetInfoResponse);

    static readonly grpc::Method<global::Lnrpc.PendingChannelsRequest, global::Lnrpc.PendingChannelsResponse> __Method_PendingChannels = new grpc::Method<global::Lnrpc.PendingChannelsRequest, global::Lnrpc.PendingChannelsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "PendingChannels",
        __Marshaller_PendingChannelsRequest,
        __Marshaller_PendingChannelsResponse);

    static readonly grpc::Method<global::Lnrpc.ListChannelsRequest, global::Lnrpc.ListChannelsResponse> __Method_ListChannels = new grpc::Method<global::Lnrpc.ListChannelsRequest, global::Lnrpc.ListChannelsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListChannels",
        __Marshaller_ListChannelsRequest,
        __Marshaller_ListChannelsResponse);

    static readonly grpc::Method<global::Lnrpc.ClosedChannelsRequest, global::Lnrpc.ClosedChannelsResponse> __Method_ClosedChannels = new grpc::Method<global::Lnrpc.ClosedChannelsRequest, global::Lnrpc.ClosedChannelsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ClosedChannels",
        __Marshaller_ClosedChannelsRequest,
        __Marshaller_ClosedChannelsResponse);

    static readonly grpc::Method<global::Lnrpc.OpenChannelRequest, global::Lnrpc.ChannelPoint> __Method_OpenChannelSync = new grpc::Method<global::Lnrpc.OpenChannelRequest, global::Lnrpc.ChannelPoint>(
        grpc::MethodType.Unary,
        __ServiceName,
        "OpenChannelSync",
        __Marshaller_OpenChannelRequest,
        __Marshaller_ChannelPoint);

    static readonly grpc::Method<global::Lnrpc.OpenChannelRequest, global::Lnrpc.OpenStatusUpdate> __Method_OpenChannel = new grpc::Method<global::Lnrpc.OpenChannelRequest, global::Lnrpc.OpenStatusUpdate>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "OpenChannel",
        __Marshaller_OpenChannelRequest,
        __Marshaller_OpenStatusUpdate);

    static readonly grpc::Method<global::Lnrpc.CloseChannelRequest, global::Lnrpc.CloseStatusUpdate> __Method_CloseChannel = new grpc::Method<global::Lnrpc.CloseChannelRequest, global::Lnrpc.CloseStatusUpdate>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "CloseChannel",
        __Marshaller_CloseChannelRequest,
        __Marshaller_CloseStatusUpdate);

    static readonly grpc::Method<global::Lnrpc.SendRequest, global::Lnrpc.SendResponse> __Method_SendPayment = new grpc::Method<global::Lnrpc.SendRequest, global::Lnrpc.SendResponse>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "SendPayment",
        __Marshaller_SendRequest,
        __Marshaller_SendResponse);

    static readonly grpc::Method<global::Lnrpc.SendRequest, global::Lnrpc.SendResponse> __Method_SendPaymentSync = new grpc::Method<global::Lnrpc.SendRequest, global::Lnrpc.SendResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SendPaymentSync",
        __Marshaller_SendRequest,
        __Marshaller_SendResponse);

    static readonly grpc::Method<global::Lnrpc.SendToRouteRequest, global::Lnrpc.SendResponse> __Method_SendToRoute = new grpc::Method<global::Lnrpc.SendToRouteRequest, global::Lnrpc.SendResponse>(
        grpc::MethodType.DuplexStreaming,
        __ServiceName,
        "SendToRoute",
        __Marshaller_SendToRouteRequest,
        __Marshaller_SendResponse);

    static readonly grpc::Method<global::Lnrpc.SendToRouteRequest, global::Lnrpc.SendResponse> __Method_SendToRouteSync = new grpc::Method<global::Lnrpc.SendToRouteRequest, global::Lnrpc.SendResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SendToRouteSync",
        __Marshaller_SendToRouteRequest,
        __Marshaller_SendResponse);

    static readonly grpc::Method<global::Lnrpc.Invoice, global::Lnrpc.AddInvoiceResponse> __Method_AddInvoice = new grpc::Method<global::Lnrpc.Invoice, global::Lnrpc.AddInvoiceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "AddInvoice",
        __Marshaller_Invoice,
        __Marshaller_AddInvoiceResponse);

    static readonly grpc::Method<global::Lnrpc.ListInvoiceRequest, global::Lnrpc.ListInvoiceResponse> __Method_ListInvoices = new grpc::Method<global::Lnrpc.ListInvoiceRequest, global::Lnrpc.ListInvoiceResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListInvoices",
        __Marshaller_ListInvoiceRequest,
        __Marshaller_ListInvoiceResponse);

    static readonly grpc::Method<global::Lnrpc.PaymentHash, global::Lnrpc.Invoice> __Method_LookupInvoice = new grpc::Method<global::Lnrpc.PaymentHash, global::Lnrpc.Invoice>(
        grpc::MethodType.Unary,
        __ServiceName,
        "LookupInvoice",
        __Marshaller_PaymentHash,
        __Marshaller_Invoice);

    static readonly grpc::Method<global::Lnrpc.InvoiceSubscription, global::Lnrpc.Invoice> __Method_SubscribeInvoices = new grpc::Method<global::Lnrpc.InvoiceSubscription, global::Lnrpc.Invoice>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "SubscribeInvoices",
        __Marshaller_InvoiceSubscription,
        __Marshaller_Invoice);

    static readonly grpc::Method<global::Lnrpc.PayReqString, global::Lnrpc.PayReq> __Method_DecodePayReq = new grpc::Method<global::Lnrpc.PayReqString, global::Lnrpc.PayReq>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DecodePayReq",
        __Marshaller_PayReqString,
        __Marshaller_PayReq);

    static readonly grpc::Method<global::Lnrpc.ListPaymentsRequest, global::Lnrpc.ListPaymentsResponse> __Method_ListPayments = new grpc::Method<global::Lnrpc.ListPaymentsRequest, global::Lnrpc.ListPaymentsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ListPayments",
        __Marshaller_ListPaymentsRequest,
        __Marshaller_ListPaymentsResponse);

    static readonly grpc::Method<global::Lnrpc.DeleteAllPaymentsRequest, global::Lnrpc.DeleteAllPaymentsResponse> __Method_DeleteAllPayments = new grpc::Method<global::Lnrpc.DeleteAllPaymentsRequest, global::Lnrpc.DeleteAllPaymentsResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DeleteAllPayments",
        __Marshaller_DeleteAllPaymentsRequest,
        __Marshaller_DeleteAllPaymentsResponse);

    static readonly grpc::Method<global::Lnrpc.ChannelGraphRequest, global::Lnrpc.ChannelGraph> __Method_DescribeGraph = new grpc::Method<global::Lnrpc.ChannelGraphRequest, global::Lnrpc.ChannelGraph>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DescribeGraph",
        __Marshaller_ChannelGraphRequest,
        __Marshaller_ChannelGraph);

    static readonly grpc::Method<global::Lnrpc.ChanInfoRequest, global::Lnrpc.ChannelEdge> __Method_GetChanInfo = new grpc::Method<global::Lnrpc.ChanInfoRequest, global::Lnrpc.ChannelEdge>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetChanInfo",
        __Marshaller_ChanInfoRequest,
        __Marshaller_ChannelEdge);

    static readonly grpc::Method<global::Lnrpc.NodeInfoRequest, global::Lnrpc.NodeInfo> __Method_GetNodeInfo = new grpc::Method<global::Lnrpc.NodeInfoRequest, global::Lnrpc.NodeInfo>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetNodeInfo",
        __Marshaller_NodeInfoRequest,
        __Marshaller_NodeInfo);

    static readonly grpc::Method<global::Lnrpc.QueryRoutesRequest, global::Lnrpc.QueryRoutesResponse> __Method_QueryRoutes = new grpc::Method<global::Lnrpc.QueryRoutesRequest, global::Lnrpc.QueryRoutesResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "QueryRoutes",
        __Marshaller_QueryRoutesRequest,
        __Marshaller_QueryRoutesResponse);

    static readonly grpc::Method<global::Lnrpc.NetworkInfoRequest, global::Lnrpc.NetworkInfo> __Method_GetNetworkInfo = new grpc::Method<global::Lnrpc.NetworkInfoRequest, global::Lnrpc.NetworkInfo>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetNetworkInfo",
        __Marshaller_NetworkInfoRequest,
        __Marshaller_NetworkInfo);

    static readonly grpc::Method<global::Lnrpc.StopRequest, global::Lnrpc.StopResponse> __Method_StopDaemon = new grpc::Method<global::Lnrpc.StopRequest, global::Lnrpc.StopResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "StopDaemon",
        __Marshaller_StopRequest,
        __Marshaller_StopResponse);

    static readonly grpc::Method<global::Lnrpc.GraphTopologySubscription, global::Lnrpc.GraphTopologyUpdate> __Method_SubscribeChannelGraph = new grpc::Method<global::Lnrpc.GraphTopologySubscription, global::Lnrpc.GraphTopologyUpdate>(
        grpc::MethodType.ServerStreaming,
        __ServiceName,
        "SubscribeChannelGraph",
        __Marshaller_GraphTopologySubscription,
        __Marshaller_GraphTopologyUpdate);

    static readonly grpc::Method<global::Lnrpc.DebugLevelRequest, global::Lnrpc.DebugLevelResponse> __Method_DebugLevel = new grpc::Method<global::Lnrpc.DebugLevelRequest, global::Lnrpc.DebugLevelResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "DebugLevel",
        __Marshaller_DebugLevelRequest,
        __Marshaller_DebugLevelResponse);

    static readonly grpc::Method<global::Lnrpc.FeeReportRequest, global::Lnrpc.FeeReportResponse> __Method_FeeReport = new grpc::Method<global::Lnrpc.FeeReportRequest, global::Lnrpc.FeeReportResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "FeeReport",
        __Marshaller_FeeReportRequest,
        __Marshaller_FeeReportResponse);

    static readonly grpc::Method<global::Lnrpc.PolicyUpdateRequest, global::Lnrpc.PolicyUpdateResponse> __Method_UpdateChannelPolicy = new grpc::Method<global::Lnrpc.PolicyUpdateRequest, global::Lnrpc.PolicyUpdateResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "UpdateChannelPolicy",
        __Marshaller_PolicyUpdateRequest,
        __Marshaller_PolicyUpdateResponse);

    static readonly grpc::Method<global::Lnrpc.ForwardingHistoryRequest, global::Lnrpc.ForwardingHistoryResponse> __Method_ForwardingHistory = new grpc::Method<global::Lnrpc.ForwardingHistoryRequest, global::Lnrpc.ForwardingHistoryResponse>(
        grpc::MethodType.Unary,
        __ServiceName,
        "ForwardingHistory",
        __Marshaller_ForwardingHistoryRequest,
        __Marshaller_ForwardingHistoryResponse);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::Lnrpc.RpcReflection.Descriptor.Services[1]; }
    }

    /// <summary>Base class for server-side implementations of Lightning</summary>
    public abstract partial class LightningBase
    {
      /// <summary>
      ///* lncli: `walletbalance`
      ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
      ///confirmed unspent outputs and all unconfirmed unspent outputs under control
      ///of the wallet. 
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.WalletBalanceResponse> WalletBalance(global::Lnrpc.WalletBalanceRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `channelbalance`
      ///ChannelBalance returns the total funds available across all open channels
      ///in satoshis.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.ChannelBalanceResponse> ChannelBalance(global::Lnrpc.ChannelBalanceRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `listchaintxns`
      ///GetTransactions returns a list describing all the known transactions
      ///relevant to the wallet.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.TransactionDetails> GetTransactions(global::Lnrpc.GetTransactionsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `sendcoins`
      ///SendCoins executes a request to send coins to a particular address. Unlike
      ///SendMany, this RPC call only allows creating a single output at a time. If
      ///neither target_conf, or sat_per_byte are set, then the internal wallet will
      ///consult its fee model to determine a fee for the default confirmation
      ///target.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.SendCoinsResponse> SendCoins(global::Lnrpc.SendCoinsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      ///SubscribeTransactions creates a uni-directional stream from the server to
      ///the client in which any newly discovered transactions relevant to the
      ///wallet are sent over.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task SubscribeTransactions(global::Lnrpc.GetTransactionsRequest request, grpc::IServerStreamWriter<global::Lnrpc.Transaction> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `sendmany`
      ///SendMany handles a request for a transaction that creates multiple specified
      ///outputs in parallel. If neither target_conf, or sat_per_byte are set, then
      ///the internal wallet will consult its fee model to determine a fee for the
      ///default confirmation target.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.SendManyResponse> SendMany(global::Lnrpc.SendManyRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `newaddress`
      ///NewAddress creates a new address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.NewAddressResponse> NewAddress(global::Lnrpc.NewAddressRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      ///NewWitnessAddress creates a new witness address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.NewAddressResponse> NewWitnessAddress(global::Lnrpc.NewWitnessAddressRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `signmessage`
      ///SignMessage signs a message with this node's private key. The returned
      ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
      ///only the message digest and signature are needed for verification.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.SignMessageResponse> SignMessage(global::Lnrpc.SignMessageRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `verifymessage`
      ///VerifyMessage verifies a signature over a msg. The signature must be
      ///zbase32 encoded and signed by an active node in the resident node's
      ///channel database. In addition to returning the validity of the signature,
      ///VerifyMessage also returns the recovered pubkey from the signature.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.VerifyMessageResponse> VerifyMessage(global::Lnrpc.VerifyMessageRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `connect`
      ///ConnectPeer attempts to establish a connection to a remote peer. This is at
      ///the networking level, and is used for communication between nodes. This is
      ///distinct from establishing a channel with a peer.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.ConnectPeerResponse> ConnectPeer(global::Lnrpc.ConnectPeerRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `disconnect`
      ///DisconnectPeer attempts to disconnect one peer from another identified by a
      ///given pubKey. In the case that we currently have a pending or active channel
      ///with the target peer, then this action will be not be allowed.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.DisconnectPeerResponse> DisconnectPeer(global::Lnrpc.DisconnectPeerRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `listpeers`
      ///ListPeers returns a verbose listing of all currently active peers.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.ListPeersResponse> ListPeers(global::Lnrpc.ListPeersRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `getinfo`
      ///GetInfo returns general information concerning the lightning node including
      ///it's identity pubkey, alias, the chains it is connected to, and information
      ///concerning the number of open+pending channels.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.GetInfoResponse> GetInfo(global::Lnrpc.GetInfoRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `pendingchannels`
      ///PendingChannels returns a list of all the channels that are currently
      ///considered "pending". A channel is pending if it has finished the funding
      ///workflow and is waiting for confirmations for the funding txn, or is in the
      ///process of closure, either initiated cooperatively or non-cooperatively.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.PendingChannelsResponse> PendingChannels(global::Lnrpc.PendingChannelsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `listchannels`
      ///ListChannels returns a description of all the open channels that this node
      ///is a participant in.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.ListChannelsResponse> ListChannels(global::Lnrpc.ListChannelsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `closedchannels`
      ///ClosedChannels returns a description of all the closed channels that 
      ///this node was a participant in.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.ClosedChannelsResponse> ClosedChannels(global::Lnrpc.ClosedChannelsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
      ///call is meant to be consumed by clients to the REST proxy. As with all
      ///other sync calls, all byte slices are intended to be populated as hex
      ///encoded strings.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.ChannelPoint> OpenChannelSync(global::Lnrpc.OpenChannelRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `openchannel`
      ///OpenChannel attempts to open a singly funded channel specified in the
      ///request to a remote peer. Users are able to specify a target number of
      ///blocks that the funding transaction should be confirmed in, or a manual fee
      ///rate to us for the funding transaction. If neither are specified, then a
      ///lax block confirmation target is used.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task OpenChannel(global::Lnrpc.OpenChannelRequest request, grpc::IServerStreamWriter<global::Lnrpc.OpenStatusUpdate> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `closechannel`
      ///CloseChannel attempts to close an active channel identified by its channel
      ///outpoint (ChannelPoint). The actions of this method can additionally be
      ///augmented to attempt a force close after a timeout period in the case of an
      ///inactive peer. If a non-force close (cooperative closure) is requested,
      ///then the user can specify either a target number of blocks until the
      ///closure transaction is confirmed, or a manual fee rate. If neither are
      ///specified, then a default lax, block confirmation target is used.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task CloseChannel(global::Lnrpc.CloseChannelRequest request, grpc::IServerStreamWriter<global::Lnrpc.CloseStatusUpdate> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `sendpayment`
      ///SendPayment dispatches a bi-directional streaming RPC for sending payments
      ///through the Lightning Network. A single RPC invocation creates a persistent
      ///bi-directional stream allowing clients to rapidly send payments through the
      ///Lightning Network with a single persistent connection.
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task SendPayment(grpc::IAsyncStreamReader<global::Lnrpc.SendRequest> requestStream, grpc::IServerStreamWriter<global::Lnrpc.SendResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
      ///This RPC is intended to be consumed by clients of the REST proxy.
      ///Additionally, this RPC expects the destination's public key and the payment
      ///hash (if any) to be encoded as hex strings.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.SendResponse> SendPaymentSync(global::Lnrpc.SendRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `sendtoroute`
      ///SendToRoute is a bi-directional streaming RPC for sending payment through
      ///the Lightning Network. This method differs from SendPayment in that it
      ///allows users to specify a full route manually. This can be used for things
      ///like rebalancing, and atomic swaps.
      /// </summary>
      /// <param name="requestStream">Used for reading requests from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task SendToRoute(grpc::IAsyncStreamReader<global::Lnrpc.SendToRouteRequest> requestStream, grpc::IServerStreamWriter<global::Lnrpc.SendResponse> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
      ///until the payment either fails or succeeds.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.SendResponse> SendToRouteSync(global::Lnrpc.SendToRouteRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `addinvoice`
      ///AddInvoice attempts to add a new invoice to the invoice database. Any
      ///duplicated invoices are rejected, therefore all invoices *must* have a
      ///unique payment preimage.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.AddInvoiceResponse> AddInvoice(global::Lnrpc.Invoice request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `listinvoices`
      ///ListInvoices returns a list of all the invoices currently stored within the
      ///database. Any active debug invoices are ignored.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.ListInvoiceResponse> ListInvoices(global::Lnrpc.ListInvoiceRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `lookupinvoice`
      ///LookupInvoice attempts to look up an invoice according to its payment hash.
      ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
      ///returned.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.Invoice> LookupInvoice(global::Lnrpc.PaymentHash request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      ///SubscribeInvoices returns a uni-directional stream (sever -> client) for
      ///notifying the client of newly added/settled invoices. The caller can
      ///optionally specify the add_index and/or the settle_index. If the add_index
      ///is specified, then we'll first start by sending add invoice events for all
      ///invoices with an add_index greater than the specified value.  If the
      ///settle_index is specified, the next, we'll send out all settle events for
      ///invoices with a settle_index greater than the specified value.  One or both
      ///of these fields can be set. If no fields are set, then we'll only send out
      ///the latest add/settle events.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task SubscribeInvoices(global::Lnrpc.InvoiceSubscription request, grpc::IServerStreamWriter<global::Lnrpc.Invoice> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `decodepayreq`
      ///DecodePayReq takes an encoded payment request string and attempts to decode
      ///it, returning a full description of the conditions encoded within the
      ///payment request.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.PayReq> DecodePayReq(global::Lnrpc.PayReqString request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `listpayments`
      ///ListPayments returns a list of all outgoing payments.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.ListPaymentsResponse> ListPayments(global::Lnrpc.ListPaymentsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      ///DeleteAllPayments deletes all outgoing payments from DB.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.DeleteAllPaymentsResponse> DeleteAllPayments(global::Lnrpc.DeleteAllPaymentsRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `describegraph`
      ///DescribeGraph returns a description of the latest graph state from the
      ///point of view of the node. The graph information is partitioned into two
      ///components: all the nodes/vertexes, and all the edges that connect the
      ///vertexes themselves.  As this is a directed graph, the edges also contain
      ///the node directional specific routing policy which includes: the time lock
      ///delta, fee information, etc.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.ChannelGraph> DescribeGraph(global::Lnrpc.ChannelGraphRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `getchaninfo`
      ///GetChanInfo returns the latest authenticated network announcement for the
      ///given channel identified by its channel ID: an 8-byte integer which
      ///uniquely identifies the location of transaction's funding output within the
      ///blockchain.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.ChannelEdge> GetChanInfo(global::Lnrpc.ChanInfoRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `getnodeinfo`
      ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
      ///channel information for the specified node identified by its public key.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.NodeInfo> GetNodeInfo(global::Lnrpc.NodeInfoRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `queryroutes`
      ///QueryRoutes attempts to query the daemon's Channel Router for a possible
      ///route to a target destination capable of carrying a specific amount of
      ///satoshis. The retuned route contains the full details required to craft and
      ///send an HTLC, also including the necessary information that should be
      ///present within the Sphinx packet encapsulated within the HTLC.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.QueryRoutesResponse> QueryRoutes(global::Lnrpc.QueryRoutesRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `getnetworkinfo`
      ///GetNetworkInfo returns some basic stats about the known channel graph from
      ///the point of view of the node.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.NetworkInfo> GetNetworkInfo(global::Lnrpc.NetworkInfoRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `stop`
      ///StopDaemon will send a shutdown request to the interrupt handler, triggering
      ///a graceful shutdown of the daemon.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.StopResponse> StopDaemon(global::Lnrpc.StopRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///*
      ///SubscribeChannelGraph launches a streaming RPC that allows the caller to
      ///receive notifications upon any changes to the channel graph topology from
      ///the point of view of the responding node. Events notified include: new
      ///nodes coming online, nodes updating their authenticated attributes, new
      ///channels being advertised, updates in the routing policy for a directional
      ///channel edge, and when channels are closed on-chain.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="responseStream">Used for sending responses back to the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>A task indicating completion of the handler.</returns>
      public virtual global::System.Threading.Tasks.Task SubscribeChannelGraph(global::Lnrpc.GraphTopologySubscription request, grpc::IServerStreamWriter<global::Lnrpc.GraphTopologyUpdate> responseStream, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `debuglevel`
      ///DebugLevel allows a caller to programmatically set the logging verbosity of
      ///lnd. The logging can be targeted according to a coarse daemon-wide logging
      ///level, or in a granular fashion to specify the logging for a target
      ///sub-system.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.DebugLevelResponse> DebugLevel(global::Lnrpc.DebugLevelRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `feereport`
      ///FeeReport allows the caller to obtain a report detailing the current fee
      ///schedule enforced by the node globally for each channel.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.FeeReportResponse> FeeReport(global::Lnrpc.FeeReportRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `updatechanpolicy`
      ///UpdateChannelPolicy allows the caller to update the fee schedule and
      ///channel policies for all channels globally, or a particular channel.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.PolicyUpdateResponse> UpdateChannelPolicy(global::Lnrpc.PolicyUpdateRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      /// <summary>
      ///* lncli: `fwdinghistory`
      ///ForwardingHistory allows the caller to query the htlcswitch for a record of
      ///all HTLC's forwarded within the target time range, and integer offset
      ///within that time range. If no time-range is specified, then the first chunk
      ///of the past 24 hrs of forwarding history are returned.
      ///
      ///A list of forwarding events are returned. The size of each forwarding event
      ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
      ///As a result each message can only contain 50k entries.  Each response has
      ///the index offset of the last entry. The index offset can be provided to the
      ///request to allow the caller to skip a series of records.
      /// </summary>
      /// <param name="request">The request received from the client.</param>
      /// <param name="context">The context of the server-side call handler being invoked.</param>
      /// <returns>The response to send back to the client (wrapped by a task).</returns>
      public virtual global::System.Threading.Tasks.Task<global::Lnrpc.ForwardingHistoryResponse> ForwardingHistory(global::Lnrpc.ForwardingHistoryRequest request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for Lightning</summary>
    public partial class LightningClient : grpc::ClientBase<LightningClient>
    {
      /// <summary>Creates a new client for Lightning</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public LightningClient(grpc::Channel channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for Lightning that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public LightningClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected LightningClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected LightningClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      /// <summary>
      ///* lncli: `walletbalance`
      ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
      ///confirmed unspent outputs and all unconfirmed unspent outputs under control
      ///of the wallet. 
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.WalletBalanceResponse WalletBalance(global::Lnrpc.WalletBalanceRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return WalletBalance(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `walletbalance`
      ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
      ///confirmed unspent outputs and all unconfirmed unspent outputs under control
      ///of the wallet. 
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.WalletBalanceResponse WalletBalance(global::Lnrpc.WalletBalanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_WalletBalance, null, options, request);
      }
      /// <summary>
      ///* lncli: `walletbalance`
      ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
      ///confirmed unspent outputs and all unconfirmed unspent outputs under control
      ///of the wallet. 
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.WalletBalanceResponse> WalletBalanceAsync(global::Lnrpc.WalletBalanceRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return WalletBalanceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `walletbalance`
      ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
      ///confirmed unspent outputs and all unconfirmed unspent outputs under control
      ///of the wallet. 
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.WalletBalanceResponse> WalletBalanceAsync(global::Lnrpc.WalletBalanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_WalletBalance, null, options, request);
      }
      /// <summary>
      ///* lncli: `channelbalance`
      ///ChannelBalance returns the total funds available across all open channels
      ///in satoshis.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelBalanceResponse ChannelBalance(global::Lnrpc.ChannelBalanceRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ChannelBalance(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `channelbalance`
      ///ChannelBalance returns the total funds available across all open channels
      ///in satoshis.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelBalanceResponse ChannelBalance(global::Lnrpc.ChannelBalanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ChannelBalance, null, options, request);
      }
      /// <summary>
      ///* lncli: `channelbalance`
      ///ChannelBalance returns the total funds available across all open channels
      ///in satoshis.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelBalanceResponse> ChannelBalanceAsync(global::Lnrpc.ChannelBalanceRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ChannelBalanceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `channelbalance`
      ///ChannelBalance returns the total funds available across all open channels
      ///in satoshis.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelBalanceResponse> ChannelBalanceAsync(global::Lnrpc.ChannelBalanceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ChannelBalance, null, options, request);
      }
      /// <summary>
      ///* lncli: `listchaintxns`
      ///GetTransactions returns a list describing all the known transactions
      ///relevant to the wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.TransactionDetails GetTransactions(global::Lnrpc.GetTransactionsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GetTransactions(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `listchaintxns`
      ///GetTransactions returns a list describing all the known transactions
      ///relevant to the wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.TransactionDetails GetTransactions(global::Lnrpc.GetTransactionsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetTransactions, null, options, request);
      }
      /// <summary>
      ///* lncli: `listchaintxns`
      ///GetTransactions returns a list describing all the known transactions
      ///relevant to the wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.TransactionDetails> GetTransactionsAsync(global::Lnrpc.GetTransactionsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GetTransactionsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `listchaintxns`
      ///GetTransactions returns a list describing all the known transactions
      ///relevant to the wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.TransactionDetails> GetTransactionsAsync(global::Lnrpc.GetTransactionsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetTransactions, null, options, request);
      }
      /// <summary>
      ///* lncli: `sendcoins`
      ///SendCoins executes a request to send coins to a particular address. Unlike
      ///SendMany, this RPC call only allows creating a single output at a time. If
      ///neither target_conf, or sat_per_byte are set, then the internal wallet will
      ///consult its fee model to determine a fee for the default confirmation
      ///target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendCoinsResponse SendCoins(global::Lnrpc.SendCoinsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SendCoins(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `sendcoins`
      ///SendCoins executes a request to send coins to a particular address. Unlike
      ///SendMany, this RPC call only allows creating a single output at a time. If
      ///neither target_conf, or sat_per_byte are set, then the internal wallet will
      ///consult its fee model to determine a fee for the default confirmation
      ///target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendCoinsResponse SendCoins(global::Lnrpc.SendCoinsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SendCoins, null, options, request);
      }
      /// <summary>
      ///* lncli: `sendcoins`
      ///SendCoins executes a request to send coins to a particular address. Unlike
      ///SendMany, this RPC call only allows creating a single output at a time. If
      ///neither target_conf, or sat_per_byte are set, then the internal wallet will
      ///consult its fee model to determine a fee for the default confirmation
      ///target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendCoinsResponse> SendCoinsAsync(global::Lnrpc.SendCoinsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SendCoinsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `sendcoins`
      ///SendCoins executes a request to send coins to a particular address. Unlike
      ///SendMany, this RPC call only allows creating a single output at a time. If
      ///neither target_conf, or sat_per_byte are set, then the internal wallet will
      ///consult its fee model to determine a fee for the default confirmation
      ///target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendCoinsResponse> SendCoinsAsync(global::Lnrpc.SendCoinsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SendCoins, null, options, request);
      }
      /// <summary>
      ///*
      ///SubscribeTransactions creates a uni-directional stream from the server to
      ///the client in which any newly discovered transactions relevant to the
      ///wallet are sent over.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.Transaction> SubscribeTransactions(global::Lnrpc.GetTransactionsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SubscribeTransactions(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///SubscribeTransactions creates a uni-directional stream from the server to
      ///the client in which any newly discovered transactions relevant to the
      ///wallet are sent over.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.Transaction> SubscribeTransactions(global::Lnrpc.GetTransactionsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_SubscribeTransactions, null, options, request);
      }
      /// <summary>
      ///* lncli: `sendmany`
      ///SendMany handles a request for a transaction that creates multiple specified
      ///outputs in parallel. If neither target_conf, or sat_per_byte are set, then
      ///the internal wallet will consult its fee model to determine a fee for the
      ///default confirmation target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendManyResponse SendMany(global::Lnrpc.SendManyRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SendMany(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `sendmany`
      ///SendMany handles a request for a transaction that creates multiple specified
      ///outputs in parallel. If neither target_conf, or sat_per_byte are set, then
      ///the internal wallet will consult its fee model to determine a fee for the
      ///default confirmation target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendManyResponse SendMany(global::Lnrpc.SendManyRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SendMany, null, options, request);
      }
      /// <summary>
      ///* lncli: `sendmany`
      ///SendMany handles a request for a transaction that creates multiple specified
      ///outputs in parallel. If neither target_conf, or sat_per_byte are set, then
      ///the internal wallet will consult its fee model to determine a fee for the
      ///default confirmation target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendManyResponse> SendManyAsync(global::Lnrpc.SendManyRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SendManyAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `sendmany`
      ///SendMany handles a request for a transaction that creates multiple specified
      ///outputs in parallel. If neither target_conf, or sat_per_byte are set, then
      ///the internal wallet will consult its fee model to determine a fee for the
      ///default confirmation target.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendManyResponse> SendManyAsync(global::Lnrpc.SendManyRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SendMany, null, options, request);
      }
      /// <summary>
      ///* lncli: `newaddress`
      ///NewAddress creates a new address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NewAddressResponse NewAddress(global::Lnrpc.NewAddressRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return NewAddress(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `newaddress`
      ///NewAddress creates a new address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NewAddressResponse NewAddress(global::Lnrpc.NewAddressRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_NewAddress, null, options, request);
      }
      /// <summary>
      ///* lncli: `newaddress`
      ///NewAddress creates a new address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NewAddressResponse> NewAddressAsync(global::Lnrpc.NewAddressRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return NewAddressAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `newaddress`
      ///NewAddress creates a new address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NewAddressResponse> NewAddressAsync(global::Lnrpc.NewAddressRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_NewAddress, null, options, request);
      }
      /// <summary>
      ///*
      ///NewWitnessAddress creates a new witness address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NewAddressResponse NewWitnessAddress(global::Lnrpc.NewWitnessAddressRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return NewWitnessAddress(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///NewWitnessAddress creates a new witness address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NewAddressResponse NewWitnessAddress(global::Lnrpc.NewWitnessAddressRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_NewWitnessAddress, null, options, request);
      }
      /// <summary>
      ///*
      ///NewWitnessAddress creates a new witness address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NewAddressResponse> NewWitnessAddressAsync(global::Lnrpc.NewWitnessAddressRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return NewWitnessAddressAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///NewWitnessAddress creates a new witness address under control of the local wallet.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NewAddressResponse> NewWitnessAddressAsync(global::Lnrpc.NewWitnessAddressRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_NewWitnessAddress, null, options, request);
      }
      /// <summary>
      ///* lncli: `signmessage`
      ///SignMessage signs a message with this node's private key. The returned
      ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
      ///only the message digest and signature are needed for verification.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SignMessageResponse SignMessage(global::Lnrpc.SignMessageRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SignMessage(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `signmessage`
      ///SignMessage signs a message with this node's private key. The returned
      ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
      ///only the message digest and signature are needed for verification.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SignMessageResponse SignMessage(global::Lnrpc.SignMessageRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SignMessage, null, options, request);
      }
      /// <summary>
      ///* lncli: `signmessage`
      ///SignMessage signs a message with this node's private key. The returned
      ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
      ///only the message digest and signature are needed for verification.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SignMessageResponse> SignMessageAsync(global::Lnrpc.SignMessageRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SignMessageAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `signmessage`
      ///SignMessage signs a message with this node's private key. The returned
      ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
      ///only the message digest and signature are needed for verification.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SignMessageResponse> SignMessageAsync(global::Lnrpc.SignMessageRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SignMessage, null, options, request);
      }
      /// <summary>
      ///* lncli: `verifymessage`
      ///VerifyMessage verifies a signature over a msg. The signature must be
      ///zbase32 encoded and signed by an active node in the resident node's
      ///channel database. In addition to returning the validity of the signature,
      ///VerifyMessage also returns the recovered pubkey from the signature.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.VerifyMessageResponse VerifyMessage(global::Lnrpc.VerifyMessageRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return VerifyMessage(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `verifymessage`
      ///VerifyMessage verifies a signature over a msg. The signature must be
      ///zbase32 encoded and signed by an active node in the resident node's
      ///channel database. In addition to returning the validity of the signature,
      ///VerifyMessage also returns the recovered pubkey from the signature.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.VerifyMessageResponse VerifyMessage(global::Lnrpc.VerifyMessageRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_VerifyMessage, null, options, request);
      }
      /// <summary>
      ///* lncli: `verifymessage`
      ///VerifyMessage verifies a signature over a msg. The signature must be
      ///zbase32 encoded and signed by an active node in the resident node's
      ///channel database. In addition to returning the validity of the signature,
      ///VerifyMessage also returns the recovered pubkey from the signature.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.VerifyMessageResponse> VerifyMessageAsync(global::Lnrpc.VerifyMessageRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return VerifyMessageAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `verifymessage`
      ///VerifyMessage verifies a signature over a msg. The signature must be
      ///zbase32 encoded and signed by an active node in the resident node's
      ///channel database. In addition to returning the validity of the signature,
      ///VerifyMessage also returns the recovered pubkey from the signature.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.VerifyMessageResponse> VerifyMessageAsync(global::Lnrpc.VerifyMessageRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_VerifyMessage, null, options, request);
      }
      /// <summary>
      ///* lncli: `connect`
      ///ConnectPeer attempts to establish a connection to a remote peer. This is at
      ///the networking level, and is used for communication between nodes. This is
      ///distinct from establishing a channel with a peer.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ConnectPeerResponse ConnectPeer(global::Lnrpc.ConnectPeerRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ConnectPeer(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `connect`
      ///ConnectPeer attempts to establish a connection to a remote peer. This is at
      ///the networking level, and is used for communication between nodes. This is
      ///distinct from establishing a channel with a peer.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ConnectPeerResponse ConnectPeer(global::Lnrpc.ConnectPeerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ConnectPeer, null, options, request);
      }
      /// <summary>
      ///* lncli: `connect`
      ///ConnectPeer attempts to establish a connection to a remote peer. This is at
      ///the networking level, and is used for communication between nodes. This is
      ///distinct from establishing a channel with a peer.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ConnectPeerResponse> ConnectPeerAsync(global::Lnrpc.ConnectPeerRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ConnectPeerAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `connect`
      ///ConnectPeer attempts to establish a connection to a remote peer. This is at
      ///the networking level, and is used for communication between nodes. This is
      ///distinct from establishing a channel with a peer.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ConnectPeerResponse> ConnectPeerAsync(global::Lnrpc.ConnectPeerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ConnectPeer, null, options, request);
      }
      /// <summary>
      ///* lncli: `disconnect`
      ///DisconnectPeer attempts to disconnect one peer from another identified by a
      ///given pubKey. In the case that we currently have a pending or active channel
      ///with the target peer, then this action will be not be allowed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DisconnectPeerResponse DisconnectPeer(global::Lnrpc.DisconnectPeerRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DisconnectPeer(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `disconnect`
      ///DisconnectPeer attempts to disconnect one peer from another identified by a
      ///given pubKey. In the case that we currently have a pending or active channel
      ///with the target peer, then this action will be not be allowed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DisconnectPeerResponse DisconnectPeer(global::Lnrpc.DisconnectPeerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DisconnectPeer, null, options, request);
      }
      /// <summary>
      ///* lncli: `disconnect`
      ///DisconnectPeer attempts to disconnect one peer from another identified by a
      ///given pubKey. In the case that we currently have a pending or active channel
      ///with the target peer, then this action will be not be allowed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DisconnectPeerResponse> DisconnectPeerAsync(global::Lnrpc.DisconnectPeerRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DisconnectPeerAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `disconnect`
      ///DisconnectPeer attempts to disconnect one peer from another identified by a
      ///given pubKey. In the case that we currently have a pending or active channel
      ///with the target peer, then this action will be not be allowed.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DisconnectPeerResponse> DisconnectPeerAsync(global::Lnrpc.DisconnectPeerRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DisconnectPeer, null, options, request);
      }
      /// <summary>
      ///* lncli: `listpeers`
      ///ListPeers returns a verbose listing of all currently active peers.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListPeersResponse ListPeers(global::Lnrpc.ListPeersRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ListPeers(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `listpeers`
      ///ListPeers returns a verbose listing of all currently active peers.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListPeersResponse ListPeers(global::Lnrpc.ListPeersRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListPeers, null, options, request);
      }
      /// <summary>
      ///* lncli: `listpeers`
      ///ListPeers returns a verbose listing of all currently active peers.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListPeersResponse> ListPeersAsync(global::Lnrpc.ListPeersRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ListPeersAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `listpeers`
      ///ListPeers returns a verbose listing of all currently active peers.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListPeersResponse> ListPeersAsync(global::Lnrpc.ListPeersRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListPeers, null, options, request);
      }
      /// <summary>
      ///* lncli: `getinfo`
      ///GetInfo returns general information concerning the lightning node including
      ///it's identity pubkey, alias, the chains it is connected to, and information
      ///concerning the number of open+pending channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.GetInfoResponse GetInfo(global::Lnrpc.GetInfoRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GetInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `getinfo`
      ///GetInfo returns general information concerning the lightning node including
      ///it's identity pubkey, alias, the chains it is connected to, and information
      ///concerning the number of open+pending channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.GetInfoResponse GetInfo(global::Lnrpc.GetInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetInfo, null, options, request);
      }
      /// <summary>
      ///* lncli: `getinfo`
      ///GetInfo returns general information concerning the lightning node including
      ///it's identity pubkey, alias, the chains it is connected to, and information
      ///concerning the number of open+pending channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.GetInfoResponse> GetInfoAsync(global::Lnrpc.GetInfoRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GetInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `getinfo`
      ///GetInfo returns general information concerning the lightning node including
      ///it's identity pubkey, alias, the chains it is connected to, and information
      ///concerning the number of open+pending channels.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.GetInfoResponse> GetInfoAsync(global::Lnrpc.GetInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetInfo, null, options, request);
      }
      /// <summary>
      ///* lncli: `pendingchannels`
      ///PendingChannels returns a list of all the channels that are currently
      ///considered "pending". A channel is pending if it has finished the funding
      ///workflow and is waiting for confirmations for the funding txn, or is in the
      ///process of closure, either initiated cooperatively or non-cooperatively.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.PendingChannelsResponse PendingChannels(global::Lnrpc.PendingChannelsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return PendingChannels(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `pendingchannels`
      ///PendingChannels returns a list of all the channels that are currently
      ///considered "pending". A channel is pending if it has finished the funding
      ///workflow and is waiting for confirmations for the funding txn, or is in the
      ///process of closure, either initiated cooperatively or non-cooperatively.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.PendingChannelsResponse PendingChannels(global::Lnrpc.PendingChannelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_PendingChannels, null, options, request);
      }
      /// <summary>
      ///* lncli: `pendingchannels`
      ///PendingChannels returns a list of all the channels that are currently
      ///considered "pending". A channel is pending if it has finished the funding
      ///workflow and is waiting for confirmations for the funding txn, or is in the
      ///process of closure, either initiated cooperatively or non-cooperatively.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.PendingChannelsResponse> PendingChannelsAsync(global::Lnrpc.PendingChannelsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return PendingChannelsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `pendingchannels`
      ///PendingChannels returns a list of all the channels that are currently
      ///considered "pending". A channel is pending if it has finished the funding
      ///workflow and is waiting for confirmations for the funding txn, or is in the
      ///process of closure, either initiated cooperatively or non-cooperatively.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.PendingChannelsResponse> PendingChannelsAsync(global::Lnrpc.PendingChannelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_PendingChannels, null, options, request);
      }
      /// <summary>
      ///* lncli: `listchannels`
      ///ListChannels returns a description of all the open channels that this node
      ///is a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListChannelsResponse ListChannels(global::Lnrpc.ListChannelsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ListChannels(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `listchannels`
      ///ListChannels returns a description of all the open channels that this node
      ///is a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListChannelsResponse ListChannels(global::Lnrpc.ListChannelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListChannels, null, options, request);
      }
      /// <summary>
      ///* lncli: `listchannels`
      ///ListChannels returns a description of all the open channels that this node
      ///is a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListChannelsResponse> ListChannelsAsync(global::Lnrpc.ListChannelsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ListChannelsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `listchannels`
      ///ListChannels returns a description of all the open channels that this node
      ///is a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListChannelsResponse> ListChannelsAsync(global::Lnrpc.ListChannelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListChannels, null, options, request);
      }
      /// <summary>
      ///* lncli: `closedchannels`
      ///ClosedChannels returns a description of all the closed channels that 
      ///this node was a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ClosedChannelsResponse ClosedChannels(global::Lnrpc.ClosedChannelsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ClosedChannels(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `closedchannels`
      ///ClosedChannels returns a description of all the closed channels that 
      ///this node was a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ClosedChannelsResponse ClosedChannels(global::Lnrpc.ClosedChannelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ClosedChannels, null, options, request);
      }
      /// <summary>
      ///* lncli: `closedchannels`
      ///ClosedChannels returns a description of all the closed channels that 
      ///this node was a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ClosedChannelsResponse> ClosedChannelsAsync(global::Lnrpc.ClosedChannelsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ClosedChannelsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `closedchannels`
      ///ClosedChannels returns a description of all the closed channels that 
      ///this node was a participant in.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ClosedChannelsResponse> ClosedChannelsAsync(global::Lnrpc.ClosedChannelsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ClosedChannels, null, options, request);
      }
      /// <summary>
      ///*
      ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
      ///call is meant to be consumed by clients to the REST proxy. As with all
      ///other sync calls, all byte slices are intended to be populated as hex
      ///encoded strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelPoint OpenChannelSync(global::Lnrpc.OpenChannelRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return OpenChannelSync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
      ///call is meant to be consumed by clients to the REST proxy. As with all
      ///other sync calls, all byte slices are intended to be populated as hex
      ///encoded strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelPoint OpenChannelSync(global::Lnrpc.OpenChannelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_OpenChannelSync, null, options, request);
      }
      /// <summary>
      ///*
      ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
      ///call is meant to be consumed by clients to the REST proxy. As with all
      ///other sync calls, all byte slices are intended to be populated as hex
      ///encoded strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelPoint> OpenChannelSyncAsync(global::Lnrpc.OpenChannelRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return OpenChannelSyncAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
      ///call is meant to be consumed by clients to the REST proxy. As with all
      ///other sync calls, all byte slices are intended to be populated as hex
      ///encoded strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelPoint> OpenChannelSyncAsync(global::Lnrpc.OpenChannelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_OpenChannelSync, null, options, request);
      }
      /// <summary>
      ///* lncli: `openchannel`
      ///OpenChannel attempts to open a singly funded channel specified in the
      ///request to a remote peer. Users are able to specify a target number of
      ///blocks that the funding transaction should be confirmed in, or a manual fee
      ///rate to us for the funding transaction. If neither are specified, then a
      ///lax block confirmation target is used.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.OpenStatusUpdate> OpenChannel(global::Lnrpc.OpenChannelRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return OpenChannel(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `openchannel`
      ///OpenChannel attempts to open a singly funded channel specified in the
      ///request to a remote peer. Users are able to specify a target number of
      ///blocks that the funding transaction should be confirmed in, or a manual fee
      ///rate to us for the funding transaction. If neither are specified, then a
      ///lax block confirmation target is used.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.OpenStatusUpdate> OpenChannel(global::Lnrpc.OpenChannelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_OpenChannel, null, options, request);
      }
      /// <summary>
      ///* lncli: `closechannel`
      ///CloseChannel attempts to close an active channel identified by its channel
      ///outpoint (ChannelPoint). The actions of this method can additionally be
      ///augmented to attempt a force close after a timeout period in the case of an
      ///inactive peer. If a non-force close (cooperative closure) is requested,
      ///then the user can specify either a target number of blocks until the
      ///closure transaction is confirmed, or a manual fee rate. If neither are
      ///specified, then a default lax, block confirmation target is used.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.CloseStatusUpdate> CloseChannel(global::Lnrpc.CloseChannelRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return CloseChannel(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `closechannel`
      ///CloseChannel attempts to close an active channel identified by its channel
      ///outpoint (ChannelPoint). The actions of this method can additionally be
      ///augmented to attempt a force close after a timeout period in the case of an
      ///inactive peer. If a non-force close (cooperative closure) is requested,
      ///then the user can specify either a target number of blocks until the
      ///closure transaction is confirmed, or a manual fee rate. If neither are
      ///specified, then a default lax, block confirmation target is used.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.CloseStatusUpdate> CloseChannel(global::Lnrpc.CloseChannelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_CloseChannel, null, options, request);
      }
      /// <summary>
      ///* lncli: `sendpayment`
      ///SendPayment dispatches a bi-directional streaming RPC for sending payments
      ///through the Lightning Network. A single RPC invocation creates a persistent
      ///bi-directional stream allowing clients to rapidly send payments through the
      ///Lightning Network with a single persistent connection.
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Lnrpc.SendRequest, global::Lnrpc.SendResponse> SendPayment(grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SendPayment(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `sendpayment`
      ///SendPayment dispatches a bi-directional streaming RPC for sending payments
      ///through the Lightning Network. A single RPC invocation creates a persistent
      ///bi-directional stream allowing clients to rapidly send payments through the
      ///Lightning Network with a single persistent connection.
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Lnrpc.SendRequest, global::Lnrpc.SendResponse> SendPayment(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_SendPayment, null, options);
      }
      /// <summary>
      ///*
      ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
      ///This RPC is intended to be consumed by clients of the REST proxy.
      ///Additionally, this RPC expects the destination's public key and the payment
      ///hash (if any) to be encoded as hex strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendResponse SendPaymentSync(global::Lnrpc.SendRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SendPaymentSync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
      ///This RPC is intended to be consumed by clients of the REST proxy.
      ///Additionally, this RPC expects the destination's public key and the payment
      ///hash (if any) to be encoded as hex strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendResponse SendPaymentSync(global::Lnrpc.SendRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SendPaymentSync, null, options, request);
      }
      /// <summary>
      ///*
      ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
      ///This RPC is intended to be consumed by clients of the REST proxy.
      ///Additionally, this RPC expects the destination's public key and the payment
      ///hash (if any) to be encoded as hex strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendResponse> SendPaymentSyncAsync(global::Lnrpc.SendRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SendPaymentSyncAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
      ///This RPC is intended to be consumed by clients of the REST proxy.
      ///Additionally, this RPC expects the destination's public key and the payment
      ///hash (if any) to be encoded as hex strings.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendResponse> SendPaymentSyncAsync(global::Lnrpc.SendRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SendPaymentSync, null, options, request);
      }
      /// <summary>
      ///* lncli: `sendtoroute`
      ///SendToRoute is a bi-directional streaming RPC for sending payment through
      ///the Lightning Network. This method differs from SendPayment in that it
      ///allows users to specify a full route manually. This can be used for things
      ///like rebalancing, and atomic swaps.
      /// </summary>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Lnrpc.SendToRouteRequest, global::Lnrpc.SendResponse> SendToRoute(grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SendToRoute(new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `sendtoroute`
      ///SendToRoute is a bi-directional streaming RPC for sending payment through
      ///the Lightning Network. This method differs from SendPayment in that it
      ///allows users to specify a full route manually. This can be used for things
      ///like rebalancing, and atomic swaps.
      /// </summary>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncDuplexStreamingCall<global::Lnrpc.SendToRouteRequest, global::Lnrpc.SendResponse> SendToRoute(grpc::CallOptions options)
      {
        return CallInvoker.AsyncDuplexStreamingCall(__Method_SendToRoute, null, options);
      }
      /// <summary>
      ///*
      ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
      ///until the payment either fails or succeeds.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendResponse SendToRouteSync(global::Lnrpc.SendToRouteRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SendToRouteSync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
      ///until the payment either fails or succeeds.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.SendResponse SendToRouteSync(global::Lnrpc.SendToRouteRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SendToRouteSync, null, options, request);
      }
      /// <summary>
      ///*
      ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
      ///until the payment either fails or succeeds.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendResponse> SendToRouteSyncAsync(global::Lnrpc.SendToRouteRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SendToRouteSyncAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
      ///until the payment either fails or succeeds.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.SendResponse> SendToRouteSyncAsync(global::Lnrpc.SendToRouteRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SendToRouteSync, null, options, request);
      }
      /// <summary>
      ///* lncli: `addinvoice`
      ///AddInvoice attempts to add a new invoice to the invoice database. Any
      ///duplicated invoices are rejected, therefore all invoices *must* have a
      ///unique payment preimage.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.AddInvoiceResponse AddInvoice(global::Lnrpc.Invoice request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return AddInvoice(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `addinvoice`
      ///AddInvoice attempts to add a new invoice to the invoice database. Any
      ///duplicated invoices are rejected, therefore all invoices *must* have a
      ///unique payment preimage.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.AddInvoiceResponse AddInvoice(global::Lnrpc.Invoice request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_AddInvoice, null, options, request);
      }
      /// <summary>
      ///* lncli: `addinvoice`
      ///AddInvoice attempts to add a new invoice to the invoice database. Any
      ///duplicated invoices are rejected, therefore all invoices *must* have a
      ///unique payment preimage.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.AddInvoiceResponse> AddInvoiceAsync(global::Lnrpc.Invoice request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return AddInvoiceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `addinvoice`
      ///AddInvoice attempts to add a new invoice to the invoice database. Any
      ///duplicated invoices are rejected, therefore all invoices *must* have a
      ///unique payment preimage.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.AddInvoiceResponse> AddInvoiceAsync(global::Lnrpc.Invoice request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_AddInvoice, null, options, request);
      }
      /// <summary>
      ///* lncli: `listinvoices`
      ///ListInvoices returns a list of all the invoices currently stored within the
      ///database. Any active debug invoices are ignored.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListInvoiceResponse ListInvoices(global::Lnrpc.ListInvoiceRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ListInvoices(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `listinvoices`
      ///ListInvoices returns a list of all the invoices currently stored within the
      ///database. Any active debug invoices are ignored.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListInvoiceResponse ListInvoices(global::Lnrpc.ListInvoiceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListInvoices, null, options, request);
      }
      /// <summary>
      ///* lncli: `listinvoices`
      ///ListInvoices returns a list of all the invoices currently stored within the
      ///database. Any active debug invoices are ignored.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListInvoiceResponse> ListInvoicesAsync(global::Lnrpc.ListInvoiceRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ListInvoicesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `listinvoices`
      ///ListInvoices returns a list of all the invoices currently stored within the
      ///database. Any active debug invoices are ignored.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListInvoiceResponse> ListInvoicesAsync(global::Lnrpc.ListInvoiceRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListInvoices, null, options, request);
      }
      /// <summary>
      ///* lncli: `lookupinvoice`
      ///LookupInvoice attempts to look up an invoice according to its payment hash.
      ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
      ///returned.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.Invoice LookupInvoice(global::Lnrpc.PaymentHash request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return LookupInvoice(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `lookupinvoice`
      ///LookupInvoice attempts to look up an invoice according to its payment hash.
      ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
      ///returned.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.Invoice LookupInvoice(global::Lnrpc.PaymentHash request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_LookupInvoice, null, options, request);
      }
      /// <summary>
      ///* lncli: `lookupinvoice`
      ///LookupInvoice attempts to look up an invoice according to its payment hash.
      ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
      ///returned.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.Invoice> LookupInvoiceAsync(global::Lnrpc.PaymentHash request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return LookupInvoiceAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `lookupinvoice`
      ///LookupInvoice attempts to look up an invoice according to its payment hash.
      ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
      ///returned.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.Invoice> LookupInvoiceAsync(global::Lnrpc.PaymentHash request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_LookupInvoice, null, options, request);
      }
      /// <summary>
      ///*
      ///SubscribeInvoices returns a uni-directional stream (sever -> client) for
      ///notifying the client of newly added/settled invoices. The caller can
      ///optionally specify the add_index and/or the settle_index. If the add_index
      ///is specified, then we'll first start by sending add invoice events for all
      ///invoices with an add_index greater than the specified value.  If the
      ///settle_index is specified, the next, we'll send out all settle events for
      ///invoices with a settle_index greater than the specified value.  One or both
      ///of these fields can be set. If no fields are set, then we'll only send out
      ///the latest add/settle events.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.Invoice> SubscribeInvoices(global::Lnrpc.InvoiceSubscription request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SubscribeInvoices(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///SubscribeInvoices returns a uni-directional stream (sever -> client) for
      ///notifying the client of newly added/settled invoices. The caller can
      ///optionally specify the add_index and/or the settle_index. If the add_index
      ///is specified, then we'll first start by sending add invoice events for all
      ///invoices with an add_index greater than the specified value.  If the
      ///settle_index is specified, the next, we'll send out all settle events for
      ///invoices with a settle_index greater than the specified value.  One or both
      ///of these fields can be set. If no fields are set, then we'll only send out
      ///the latest add/settle events.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.Invoice> SubscribeInvoices(global::Lnrpc.InvoiceSubscription request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_SubscribeInvoices, null, options, request);
      }
      /// <summary>
      ///* lncli: `decodepayreq`
      ///DecodePayReq takes an encoded payment request string and attempts to decode
      ///it, returning a full description of the conditions encoded within the
      ///payment request.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.PayReq DecodePayReq(global::Lnrpc.PayReqString request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DecodePayReq(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `decodepayreq`
      ///DecodePayReq takes an encoded payment request string and attempts to decode
      ///it, returning a full description of the conditions encoded within the
      ///payment request.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.PayReq DecodePayReq(global::Lnrpc.PayReqString request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DecodePayReq, null, options, request);
      }
      /// <summary>
      ///* lncli: `decodepayreq`
      ///DecodePayReq takes an encoded payment request string and attempts to decode
      ///it, returning a full description of the conditions encoded within the
      ///payment request.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.PayReq> DecodePayReqAsync(global::Lnrpc.PayReqString request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DecodePayReqAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `decodepayreq`
      ///DecodePayReq takes an encoded payment request string and attempts to decode
      ///it, returning a full description of the conditions encoded within the
      ///payment request.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.PayReq> DecodePayReqAsync(global::Lnrpc.PayReqString request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DecodePayReq, null, options, request);
      }
      /// <summary>
      ///* lncli: `listpayments`
      ///ListPayments returns a list of all outgoing payments.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListPaymentsResponse ListPayments(global::Lnrpc.ListPaymentsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ListPayments(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `listpayments`
      ///ListPayments returns a list of all outgoing payments.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ListPaymentsResponse ListPayments(global::Lnrpc.ListPaymentsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ListPayments, null, options, request);
      }
      /// <summary>
      ///* lncli: `listpayments`
      ///ListPayments returns a list of all outgoing payments.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListPaymentsResponse> ListPaymentsAsync(global::Lnrpc.ListPaymentsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ListPaymentsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `listpayments`
      ///ListPayments returns a list of all outgoing payments.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ListPaymentsResponse> ListPaymentsAsync(global::Lnrpc.ListPaymentsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ListPayments, null, options, request);
      }
      /// <summary>
      ///*
      ///DeleteAllPayments deletes all outgoing payments from DB.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DeleteAllPaymentsResponse DeleteAllPayments(global::Lnrpc.DeleteAllPaymentsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DeleteAllPayments(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///DeleteAllPayments deletes all outgoing payments from DB.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DeleteAllPaymentsResponse DeleteAllPayments(global::Lnrpc.DeleteAllPaymentsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DeleteAllPayments, null, options, request);
      }
      /// <summary>
      ///*
      ///DeleteAllPayments deletes all outgoing payments from DB.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DeleteAllPaymentsResponse> DeleteAllPaymentsAsync(global::Lnrpc.DeleteAllPaymentsRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DeleteAllPaymentsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///DeleteAllPayments deletes all outgoing payments from DB.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DeleteAllPaymentsResponse> DeleteAllPaymentsAsync(global::Lnrpc.DeleteAllPaymentsRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DeleteAllPayments, null, options, request);
      }
      /// <summary>
      ///* lncli: `describegraph`
      ///DescribeGraph returns a description of the latest graph state from the
      ///point of view of the node. The graph information is partitioned into two
      ///components: all the nodes/vertexes, and all the edges that connect the
      ///vertexes themselves.  As this is a directed graph, the edges also contain
      ///the node directional specific routing policy which includes: the time lock
      ///delta, fee information, etc.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelGraph DescribeGraph(global::Lnrpc.ChannelGraphRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DescribeGraph(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `describegraph`
      ///DescribeGraph returns a description of the latest graph state from the
      ///point of view of the node. The graph information is partitioned into two
      ///components: all the nodes/vertexes, and all the edges that connect the
      ///vertexes themselves.  As this is a directed graph, the edges also contain
      ///the node directional specific routing policy which includes: the time lock
      ///delta, fee information, etc.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelGraph DescribeGraph(global::Lnrpc.ChannelGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DescribeGraph, null, options, request);
      }
      /// <summary>
      ///* lncli: `describegraph`
      ///DescribeGraph returns a description of the latest graph state from the
      ///point of view of the node. The graph information is partitioned into two
      ///components: all the nodes/vertexes, and all the edges that connect the
      ///vertexes themselves.  As this is a directed graph, the edges also contain
      ///the node directional specific routing policy which includes: the time lock
      ///delta, fee information, etc.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelGraph> DescribeGraphAsync(global::Lnrpc.ChannelGraphRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DescribeGraphAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `describegraph`
      ///DescribeGraph returns a description of the latest graph state from the
      ///point of view of the node. The graph information is partitioned into two
      ///components: all the nodes/vertexes, and all the edges that connect the
      ///vertexes themselves.  As this is a directed graph, the edges also contain
      ///the node directional specific routing policy which includes: the time lock
      ///delta, fee information, etc.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelGraph> DescribeGraphAsync(global::Lnrpc.ChannelGraphRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DescribeGraph, null, options, request);
      }
      /// <summary>
      ///* lncli: `getchaninfo`
      ///GetChanInfo returns the latest authenticated network announcement for the
      ///given channel identified by its channel ID: an 8-byte integer which
      ///uniquely identifies the location of transaction's funding output within the
      ///blockchain.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelEdge GetChanInfo(global::Lnrpc.ChanInfoRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GetChanInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `getchaninfo`
      ///GetChanInfo returns the latest authenticated network announcement for the
      ///given channel identified by its channel ID: an 8-byte integer which
      ///uniquely identifies the location of transaction's funding output within the
      ///blockchain.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ChannelEdge GetChanInfo(global::Lnrpc.ChanInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetChanInfo, null, options, request);
      }
      /// <summary>
      ///* lncli: `getchaninfo`
      ///GetChanInfo returns the latest authenticated network announcement for the
      ///given channel identified by its channel ID: an 8-byte integer which
      ///uniquely identifies the location of transaction's funding output within the
      ///blockchain.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelEdge> GetChanInfoAsync(global::Lnrpc.ChanInfoRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GetChanInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `getchaninfo`
      ///GetChanInfo returns the latest authenticated network announcement for the
      ///given channel identified by its channel ID: an 8-byte integer which
      ///uniquely identifies the location of transaction's funding output within the
      ///blockchain.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ChannelEdge> GetChanInfoAsync(global::Lnrpc.ChanInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetChanInfo, null, options, request);
      }
      /// <summary>
      ///* lncli: `getnodeinfo`
      ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
      ///channel information for the specified node identified by its public key.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NodeInfo GetNodeInfo(global::Lnrpc.NodeInfoRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GetNodeInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `getnodeinfo`
      ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
      ///channel information for the specified node identified by its public key.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NodeInfo GetNodeInfo(global::Lnrpc.NodeInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetNodeInfo, null, options, request);
      }
      /// <summary>
      ///* lncli: `getnodeinfo`
      ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
      ///channel information for the specified node identified by its public key.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NodeInfo> GetNodeInfoAsync(global::Lnrpc.NodeInfoRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GetNodeInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `getnodeinfo`
      ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
      ///channel information for the specified node identified by its public key.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NodeInfo> GetNodeInfoAsync(global::Lnrpc.NodeInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetNodeInfo, null, options, request);
      }
      /// <summary>
      ///* lncli: `queryroutes`
      ///QueryRoutes attempts to query the daemon's Channel Router for a possible
      ///route to a target destination capable of carrying a specific amount of
      ///satoshis. The retuned route contains the full details required to craft and
      ///send an HTLC, also including the necessary information that should be
      ///present within the Sphinx packet encapsulated within the HTLC.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.QueryRoutesResponse QueryRoutes(global::Lnrpc.QueryRoutesRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return QueryRoutes(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `queryroutes`
      ///QueryRoutes attempts to query the daemon's Channel Router for a possible
      ///route to a target destination capable of carrying a specific amount of
      ///satoshis. The retuned route contains the full details required to craft and
      ///send an HTLC, also including the necessary information that should be
      ///present within the Sphinx packet encapsulated within the HTLC.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.QueryRoutesResponse QueryRoutes(global::Lnrpc.QueryRoutesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_QueryRoutes, null, options, request);
      }
      /// <summary>
      ///* lncli: `queryroutes`
      ///QueryRoutes attempts to query the daemon's Channel Router for a possible
      ///route to a target destination capable of carrying a specific amount of
      ///satoshis. The retuned route contains the full details required to craft and
      ///send an HTLC, also including the necessary information that should be
      ///present within the Sphinx packet encapsulated within the HTLC.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.QueryRoutesResponse> QueryRoutesAsync(global::Lnrpc.QueryRoutesRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return QueryRoutesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `queryroutes`
      ///QueryRoutes attempts to query the daemon's Channel Router for a possible
      ///route to a target destination capable of carrying a specific amount of
      ///satoshis. The retuned route contains the full details required to craft and
      ///send an HTLC, also including the necessary information that should be
      ///present within the Sphinx packet encapsulated within the HTLC.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.QueryRoutesResponse> QueryRoutesAsync(global::Lnrpc.QueryRoutesRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_QueryRoutes, null, options, request);
      }
      /// <summary>
      ///* lncli: `getnetworkinfo`
      ///GetNetworkInfo returns some basic stats about the known channel graph from
      ///the point of view of the node.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NetworkInfo GetNetworkInfo(global::Lnrpc.NetworkInfoRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GetNetworkInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `getnetworkinfo`
      ///GetNetworkInfo returns some basic stats about the known channel graph from
      ///the point of view of the node.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.NetworkInfo GetNetworkInfo(global::Lnrpc.NetworkInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetNetworkInfo, null, options, request);
      }
      /// <summary>
      ///* lncli: `getnetworkinfo`
      ///GetNetworkInfo returns some basic stats about the known channel graph from
      ///the point of view of the node.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NetworkInfo> GetNetworkInfoAsync(global::Lnrpc.NetworkInfoRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return GetNetworkInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `getnetworkinfo`
      ///GetNetworkInfo returns some basic stats about the known channel graph from
      ///the point of view of the node.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.NetworkInfo> GetNetworkInfoAsync(global::Lnrpc.NetworkInfoRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetNetworkInfo, null, options, request);
      }
      /// <summary>
      ///* lncli: `stop`
      ///StopDaemon will send a shutdown request to the interrupt handler, triggering
      ///a graceful shutdown of the daemon.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.StopResponse StopDaemon(global::Lnrpc.StopRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return StopDaemon(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `stop`
      ///StopDaemon will send a shutdown request to the interrupt handler, triggering
      ///a graceful shutdown of the daemon.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.StopResponse StopDaemon(global::Lnrpc.StopRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_StopDaemon, null, options, request);
      }
      /// <summary>
      ///* lncli: `stop`
      ///StopDaemon will send a shutdown request to the interrupt handler, triggering
      ///a graceful shutdown of the daemon.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.StopResponse> StopDaemonAsync(global::Lnrpc.StopRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return StopDaemonAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `stop`
      ///StopDaemon will send a shutdown request to the interrupt handler, triggering
      ///a graceful shutdown of the daemon.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.StopResponse> StopDaemonAsync(global::Lnrpc.StopRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_StopDaemon, null, options, request);
      }
      /// <summary>
      ///*
      ///SubscribeChannelGraph launches a streaming RPC that allows the caller to
      ///receive notifications upon any changes to the channel graph topology from
      ///the point of view of the responding node. Events notified include: new
      ///nodes coming online, nodes updating their authenticated attributes, new
      ///channels being advertised, updates in the routing policy for a directional
      ///channel edge, and when channels are closed on-chain.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.GraphTopologyUpdate> SubscribeChannelGraph(global::Lnrpc.GraphTopologySubscription request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return SubscribeChannelGraph(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///*
      ///SubscribeChannelGraph launches a streaming RPC that allows the caller to
      ///receive notifications upon any changes to the channel graph topology from
      ///the point of view of the responding node. Events notified include: new
      ///nodes coming online, nodes updating their authenticated attributes, new
      ///channels being advertised, updates in the routing policy for a directional
      ///channel edge, and when channels are closed on-chain.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncServerStreamingCall<global::Lnrpc.GraphTopologyUpdate> SubscribeChannelGraph(global::Lnrpc.GraphTopologySubscription request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncServerStreamingCall(__Method_SubscribeChannelGraph, null, options, request);
      }
      /// <summary>
      ///* lncli: `debuglevel`
      ///DebugLevel allows a caller to programmatically set the logging verbosity of
      ///lnd. The logging can be targeted according to a coarse daemon-wide logging
      ///level, or in a granular fashion to specify the logging for a target
      ///sub-system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DebugLevelResponse DebugLevel(global::Lnrpc.DebugLevelRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DebugLevel(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `debuglevel`
      ///DebugLevel allows a caller to programmatically set the logging verbosity of
      ///lnd. The logging can be targeted according to a coarse daemon-wide logging
      ///level, or in a granular fashion to specify the logging for a target
      ///sub-system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.DebugLevelResponse DebugLevel(global::Lnrpc.DebugLevelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_DebugLevel, null, options, request);
      }
      /// <summary>
      ///* lncli: `debuglevel`
      ///DebugLevel allows a caller to programmatically set the logging verbosity of
      ///lnd. The logging can be targeted according to a coarse daemon-wide logging
      ///level, or in a granular fashion to specify the logging for a target
      ///sub-system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DebugLevelResponse> DebugLevelAsync(global::Lnrpc.DebugLevelRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return DebugLevelAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `debuglevel`
      ///DebugLevel allows a caller to programmatically set the logging verbosity of
      ///lnd. The logging can be targeted according to a coarse daemon-wide logging
      ///level, or in a granular fashion to specify the logging for a target
      ///sub-system.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.DebugLevelResponse> DebugLevelAsync(global::Lnrpc.DebugLevelRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_DebugLevel, null, options, request);
      }
      /// <summary>
      ///* lncli: `feereport`
      ///FeeReport allows the caller to obtain a report detailing the current fee
      ///schedule enforced by the node globally for each channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.FeeReportResponse FeeReport(global::Lnrpc.FeeReportRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return FeeReport(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `feereport`
      ///FeeReport allows the caller to obtain a report detailing the current fee
      ///schedule enforced by the node globally for each channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.FeeReportResponse FeeReport(global::Lnrpc.FeeReportRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_FeeReport, null, options, request);
      }
      /// <summary>
      ///* lncli: `feereport`
      ///FeeReport allows the caller to obtain a report detailing the current fee
      ///schedule enforced by the node globally for each channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.FeeReportResponse> FeeReportAsync(global::Lnrpc.FeeReportRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return FeeReportAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `feereport`
      ///FeeReport allows the caller to obtain a report detailing the current fee
      ///schedule enforced by the node globally for each channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.FeeReportResponse> FeeReportAsync(global::Lnrpc.FeeReportRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_FeeReport, null, options, request);
      }
      /// <summary>
      ///* lncli: `updatechanpolicy`
      ///UpdateChannelPolicy allows the caller to update the fee schedule and
      ///channel policies for all channels globally, or a particular channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.PolicyUpdateResponse UpdateChannelPolicy(global::Lnrpc.PolicyUpdateRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return UpdateChannelPolicy(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `updatechanpolicy`
      ///UpdateChannelPolicy allows the caller to update the fee schedule and
      ///channel policies for all channels globally, or a particular channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.PolicyUpdateResponse UpdateChannelPolicy(global::Lnrpc.PolicyUpdateRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_UpdateChannelPolicy, null, options, request);
      }
      /// <summary>
      ///* lncli: `updatechanpolicy`
      ///UpdateChannelPolicy allows the caller to update the fee schedule and
      ///channel policies for all channels globally, or a particular channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.PolicyUpdateResponse> UpdateChannelPolicyAsync(global::Lnrpc.PolicyUpdateRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return UpdateChannelPolicyAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `updatechanpolicy`
      ///UpdateChannelPolicy allows the caller to update the fee schedule and
      ///channel policies for all channels globally, or a particular channel.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.PolicyUpdateResponse> UpdateChannelPolicyAsync(global::Lnrpc.PolicyUpdateRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_UpdateChannelPolicy, null, options, request);
      }
      /// <summary>
      ///* lncli: `fwdinghistory`
      ///ForwardingHistory allows the caller to query the htlcswitch for a record of
      ///all HTLC's forwarded within the target time range, and integer offset
      ///within that time range. If no time-range is specified, then the first chunk
      ///of the past 24 hrs of forwarding history are returned.
      ///
      ///A list of forwarding events are returned. The size of each forwarding event
      ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
      ///As a result each message can only contain 50k entries.  Each response has
      ///the index offset of the last entry. The index offset can be provided to the
      ///request to allow the caller to skip a series of records.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ForwardingHistoryResponse ForwardingHistory(global::Lnrpc.ForwardingHistoryRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ForwardingHistory(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `fwdinghistory`
      ///ForwardingHistory allows the caller to query the htlcswitch for a record of
      ///all HTLC's forwarded within the target time range, and integer offset
      ///within that time range. If no time-range is specified, then the first chunk
      ///of the past 24 hrs of forwarding history are returned.
      ///
      ///A list of forwarding events are returned. The size of each forwarding event
      ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
      ///As a result each message can only contain 50k entries.  Each response has
      ///the index offset of the last entry. The index offset can be provided to the
      ///request to allow the caller to skip a series of records.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The response received from the server.</returns>
      public virtual global::Lnrpc.ForwardingHistoryResponse ForwardingHistory(global::Lnrpc.ForwardingHistoryRequest request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_ForwardingHistory, null, options, request);
      }
      /// <summary>
      ///* lncli: `fwdinghistory`
      ///ForwardingHistory allows the caller to query the htlcswitch for a record of
      ///all HTLC's forwarded within the target time range, and integer offset
      ///within that time range. If no time-range is specified, then the first chunk
      ///of the past 24 hrs of forwarding history are returned.
      ///
      ///A list of forwarding events are returned. The size of each forwarding event
      ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
      ///As a result each message can only contain 50k entries.  Each response has
      ///the index offset of the last entry. The index offset can be provided to the
      ///request to allow the caller to skip a series of records.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
      /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
      /// <param name="cancellationToken">An optional token for canceling the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ForwardingHistoryResponse> ForwardingHistoryAsync(global::Lnrpc.ForwardingHistoryRequest request, grpc::Metadata headers = null, DateTime? deadline = null, CancellationToken cancellationToken = default(CancellationToken))
      {
        return ForwardingHistoryAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      /// <summary>
      ///* lncli: `fwdinghistory`
      ///ForwardingHistory allows the caller to query the htlcswitch for a record of
      ///all HTLC's forwarded within the target time range, and integer offset
      ///within that time range. If no time-range is specified, then the first chunk
      ///of the past 24 hrs of forwarding history are returned.
      ///
      ///A list of forwarding events are returned. The size of each forwarding event
      ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
      ///As a result each message can only contain 50k entries.  Each response has
      ///the index offset of the last entry. The index offset can be provided to the
      ///request to allow the caller to skip a series of records.
      /// </summary>
      /// <param name="request">The request to send to the server.</param>
      /// <param name="options">The options for the call.</param>
      /// <returns>The call object.</returns>
      public virtual grpc::AsyncUnaryCall<global::Lnrpc.ForwardingHistoryResponse> ForwardingHistoryAsync(global::Lnrpc.ForwardingHistoryRequest request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_ForwardingHistory, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override LightningClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new LightningClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static grpc::ServerServiceDefinition BindService(LightningBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_WalletBalance, serviceImpl.WalletBalance)
          .AddMethod(__Method_ChannelBalance, serviceImpl.ChannelBalance)
          .AddMethod(__Method_GetTransactions, serviceImpl.GetTransactions)
          .AddMethod(__Method_SendCoins, serviceImpl.SendCoins)
          .AddMethod(__Method_SubscribeTransactions, serviceImpl.SubscribeTransactions)
          .AddMethod(__Method_SendMany, serviceImpl.SendMany)
          .AddMethod(__Method_NewAddress, serviceImpl.NewAddress)
          .AddMethod(__Method_NewWitnessAddress, serviceImpl.NewWitnessAddress)
          .AddMethod(__Method_SignMessage, serviceImpl.SignMessage)
          .AddMethod(__Method_VerifyMessage, serviceImpl.VerifyMessage)
          .AddMethod(__Method_ConnectPeer, serviceImpl.ConnectPeer)
          .AddMethod(__Method_DisconnectPeer, serviceImpl.DisconnectPeer)
          .AddMethod(__Method_ListPeers, serviceImpl.ListPeers)
          .AddMethod(__Method_GetInfo, serviceImpl.GetInfo)
          .AddMethod(__Method_PendingChannels, serviceImpl.PendingChannels)
          .AddMethod(__Method_ListChannels, serviceImpl.ListChannels)
          .AddMethod(__Method_ClosedChannels, serviceImpl.ClosedChannels)
          .AddMethod(__Method_OpenChannelSync, serviceImpl.OpenChannelSync)
          .AddMethod(__Method_OpenChannel, serviceImpl.OpenChannel)
          .AddMethod(__Method_CloseChannel, serviceImpl.CloseChannel)
          .AddMethod(__Method_SendPayment, serviceImpl.SendPayment)
          .AddMethod(__Method_SendPaymentSync, serviceImpl.SendPaymentSync)
          .AddMethod(__Method_SendToRoute, serviceImpl.SendToRoute)
          .AddMethod(__Method_SendToRouteSync, serviceImpl.SendToRouteSync)
          .AddMethod(__Method_AddInvoice, serviceImpl.AddInvoice)
          .AddMethod(__Method_ListInvoices, serviceImpl.ListInvoices)
          .AddMethod(__Method_LookupInvoice, serviceImpl.LookupInvoice)
          .AddMethod(__Method_SubscribeInvoices, serviceImpl.SubscribeInvoices)
          .AddMethod(__Method_DecodePayReq, serviceImpl.DecodePayReq)
          .AddMethod(__Method_ListPayments, serviceImpl.ListPayments)
          .AddMethod(__Method_DeleteAllPayments, serviceImpl.DeleteAllPayments)
          .AddMethod(__Method_DescribeGraph, serviceImpl.DescribeGraph)
          .AddMethod(__Method_GetChanInfo, serviceImpl.GetChanInfo)
          .AddMethod(__Method_GetNodeInfo, serviceImpl.GetNodeInfo)
          .AddMethod(__Method_QueryRoutes, serviceImpl.QueryRoutes)
          .AddMethod(__Method_GetNetworkInfo, serviceImpl.GetNetworkInfo)
          .AddMethod(__Method_StopDaemon, serviceImpl.StopDaemon)
          .AddMethod(__Method_SubscribeChannelGraph, serviceImpl.SubscribeChannelGraph)
          .AddMethod(__Method_DebugLevel, serviceImpl.DebugLevel)
          .AddMethod(__Method_FeeReport, serviceImpl.FeeReport)
          .AddMethod(__Method_UpdateChannelPolicy, serviceImpl.UpdateChannelPolicy)
          .AddMethod(__Method_ForwardingHistory, serviceImpl.ForwardingHistory).Build();
    }

  }
}
#endregion
